#!/usr/bin/env python
# coding: utf-8

# ## **Modelling Well Test Analysis in O&G**
# 
# Objectives: 
# * Model various well tests for different analysis based on the available well test data. 
# * Calculating various reservoir parameters including *Permeability (K)*, *Skin (S)*, etc for **Wellbore Storage Period** and **Transient Flow Period**.
# 
# @author: Preet Kothari
# 
# @email: preetkothari19@gmail.com
# 
# Note: 
# Work Under Progress.

# ### **Functions**

# #### **Initialization and Plots**



def Input_Data(q=0,tp=0,Pi=0,h=0,phi=0,ct=0,B=0,mu=0,rw=0):
    """Collects values of Flow Rate (q), Test Time Period (tp),
       Initial Reservoir Pressure (Pi), Formation Thickness (h),
       Porosity (phi), Total Compressibility (ct), Formation Volumne Factor (B),
       Oil Viscosity (mu), and Wellbore Radius (rw). 
       Returns a Dictionary with same keys.
    """
  
    import pandas as pd
    import numpy as np
    
    # For storing well and reservoir rock & fluid properties
    dict_data = {'q':q,'tp':tp,'Pi':Pi,'h':h,'phi':phi,'ct':ct,'B':B,'mu':mu,'rw':rw}
    if (q==0):
        dict_data['q'] = float(input("Enter Flow Rate in STB/D, q: "))
        dict_data['tp'] = float(input("Enter Time Period of test in hrs, tp: "))
        dict_data['Pi'] = float(input("Enter Initial Reservoir Pressure in psi, Pi: "))
        dict_data['h'] = float(input("Enter Formation Thickness in ft, h: "))
        dict_data['phi'] = float(input("Enter Porosity, phi: "))
        dict_data['ct'] = float(input("Enter Total Compressibility in per psi, ct: ")) 
        dict_data['B'] = float(input("Enter FVF in RB/STB, B: "))
        dict_data['mu'] = float(input("Enter Oil Viscosity in cP, mu: "))
        dict_data['rw'] = float(input("Enter Wellbore Radius in ft, rw: "))
    else:
        dict_data['q'] = q
        dict_data['tp'] = tp
        dict_data['Pi'] = Pi
        dict_data['h'] = h
        dict_data['phi'] = phi 
        dict_data['ct'] = ct
        dict_data['B'] = B
        dict_data['mu'] = mu
        dict_data['rw'] = rw
        
    return dict_data



def Well_Dataframe(dict_data,df):
    """Returns a dataframe containing Time (t), Flowing Bottomhole Pressure (Pwf), 
       delP (delta P = P1-P2), dt (dt = t1-t2),
       dP (dP = delta P1-delta P2), P_dash (dp/dt).
       List of inputs (in same order):
       - Dictionary of Reservoir fluid & rock and Well data
       - Dataframe of Welltest Data       
    """
  
    import pandas as pd
    import numpy as np
  
    # For Pi-Pwf or Delta P
    df['delP'] = dict_data['Pi'] - df['Pwf']
    # For dP and dt
    t = np.array(df['t'])
    p = np.array(df['delP'])
    dt = []
    dp = []
    for i in range(len(t)):
        if i==0:
            dt.append(t[i])
            dp.append(p[i])
        else:
            dt.append(t[i] - t[i-1])
            dp.append(p[i] - p[i-1])
    dt = np.array(dt)
    dp = np.array(dp)
    df['dt'] = dt
    df['dP'] = dp
    # For P' = t*dp/dt
    df['P_dash']=np.zeros(df.shape[0])
    df['P_dash'][1:] = (df['t'][1:])*(df['dP'][1:])/df['dt'][1:]
    return df



def WellTest_Plot(df,plt_type,para_1='t',para_2='Pwf',lbl='Pwf Plot',title='Drawdown Test',xl='Time, hrs',yl='Pwf, psia'):
    """Returns a Plot (Cartesian, Semilog or Log-Log) of the 
       provided parameters.
       List of inputs (in same order):
       - Dataframe of Welltest Data
       - Plot type (cartesian, semilog, or log)
       - Parameter 1 (defaut: t)
       - Parameter 2 (defaut: Pwf)
       - Plot Label (defaut: Pwf Plot)
       - Plot Title (defaut: Drawdown Test)
       - X-Axis Title (defaut: Time, hrs)
       - Y-Axis Title (defaut: Pwf, Psia)
    """
  
    import matplotlib.pyplot as plt
    import seaborn as sns
    plt.style.use('fivethirtyeight')
    get_ipython().run_line_magic('matplotlib', 'inline')

    # To ignore warnings generated by the current version of seaborn 
    import warnings                  
    warnings.filterwarnings("ignore")

    # Defining plot parameters 
    plt.style.use('default')
    plt.figure(figsize=(10,5))

    if (plt_type == 'cartesian'):
        plt.plot(df[para_1][0:], df[para_2][0:],linestyle='--', marker='o', color='b',label=lbl)
    elif (plt_type == 'semilog'):
        plt.semilogx(df[para_1][0:], df[para_2][0:],linestyle='--', marker='o', color='b',label=lbl)
    elif (plt_type == "log"):
        plt.loglog(df[para_1][0:], df[para_2][0:],linestyle='--', marker='o', color='b',label=lbl)

    plt.title(title)

    plt.xlabel(xl)
    plt.ylabel(yl)

    plt.legend(loc='best')
    plt.grid()



def Derivative_Plot(df,plt_type,para_1='t',para_2='Pwf',lbl='Pwf Plot',title='Drawdown Test',xl='Time, hrs',yl='Pwf, psia'):
    """Returns a Derivative Plot and a Plot (Cartesian, Semilog or Log-Log) of the 
       provided parameters.
       List of inputs (in same order):
       - Dataframe of Welltest Data
       - Plot type (cartesian, semilog, or log)
       - Parameter 1 (defaut: t)
       - Parameter 2 (defaut: Pwf)
       - Plot Label (defaut: Pwf Plot)
       - Plot Title (defaut: Drawdown Test)
       - X-Axis Title (defaut: Time, hrs)
       - Y-Axis Title (defaut: Pwf, Psia)
    """
  
    import matplotlib.pyplot as plt
    import seaborn as sns
    plt.style.use('fivethirtyeight')
    get_ipython().run_line_magic('matplotlib', 'inline')

    # To ignore warnings generated by the current version of seaborn 
    import warnings                  
    warnings.filterwarnings("ignore")

    # Defining plot parameters
    plt.style.use('default')
    plt.figure(figsize=(10,5))

    if (plt_type == 'cartesian'):
        plt.plot(df['t'][1:], df['P_dash'][1:],linestyle='--', marker='o', color='b',label='Derivative Plot')
        plt.plot(df[para_1][1:], df[para_2][1:],linestyle='--', marker='o', color='r',label=lbl)
    elif (plt_type == 'semilog'):
        plt.semilogx(df['t'][1:], df['P_dash'][1:],linestyle='--', marker='o', color='b',label='Derivative Plot')
        plt.semilogx(df[para_1][1:], df[para_2][1:],linestyle='--', marker='o', color='r',label=lbl)
    elif (plt_type == 'log'):
        plt.loglog(df['t'][1:], df['P_dash'][1:],linestyle='--', marker='o', color='b',label='Derivative Plot')
        plt.loglog(df[para_1][1:], df[para_2][1:],linestyle='--', marker='o', color='r',label=lbl)
  
    plt.title(title)

    plt.xlabel(xl)
    plt.ylabel(yl)

    plt.legend(loc='best')
    plt.grid()


# #### **Finding FWBS and IARF Period**


def t_period(df,plt_type):
    """Returns a Derivative Plot and a Plot (Cartesian, Semilog or Log-Log) of the 
       provided parameters on which using a draggable line FWBS and IARF time periods can be identified.
       List of inputs (in same order):
       - Dataframe of Welltest Data
       - Plot type (semilog or log)
    """
    
    import sys
    import pandas as pd
    import numpy as np
    import seaborn as sns
    import matplotlib
    import matplotlib.pyplot as plt
    import matplotlib.patches as patches
    from matplotlib.lines import Line2D
    from matplotlib.figure import Figure
    matplotlib.use("Qt5Agg")
    from PyQt5 import QtCore, QtGui, QtWidgets, uic
    from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas, NavigationToolbar2QT as NavigationToolbar
    get_ipython().run_line_magic('matplotlib', 'notebook')

    # To ignore warnings generated by the current version of seaborn 
    import warnings                  
    warnings.filterwarnings("ignore")

    Dragpoint_list = []
    class DraggablePoint:

        lock = None #  only one can be animated at a time

        def __init__(self, parent, x=0.1, y=0.1, size=0.1):

            self.parent = parent
            self.point = patches.Ellipse((x, y), size, size * 3, fc='r', alpha=0.5, edgecolor='r')
            self.x = x
            self.y = y
            parent.fig.axes[0].add_patch(self.point)
            self.press = None
            self.background = None
            self.connect()

            # if another point already exist we draw a line
            if self.parent.list_points:
                line_x = [self.parent.list_points[-1].x, self.x]
                line_y = [self.parent.list_points[-1].y, self.y]

                self.line = Line2D(line_x, line_y, color='r', alpha=0.5)
                parent.fig.axes[0].add_line(self.line)


        def connect(self):

            'connect to all the events we need'

            self.cidpress = self.point.figure.canvas.mpl_connect('button_press_event', self.on_press)
            self.cidrelease = self.point.figure.canvas.mpl_connect('button_release_event', self.on_release)
            self.cidmotion = self.point.figure.canvas.mpl_connect('motion_notify_event', self.on_motion)


        def on_press(self, event):

            if event.inaxes != self.point.axes: return
            if DraggablePoint.lock is not None: return
            contains, attrd = self.point.contains(event)
            if not contains: return
            self.press = (self.point.center), event.xdata, event.ydata
            DraggablePoint.lock = self

            # draw everything but the selected rectangle and store the pixel buffer
            canvas = self.point.figure.canvas
            axes = self.point.axes
            self.point.set_animated(True)

            # TODO also the line of some other points needs to be released
            point_number =  self.parent.list_points.index(self)

            if self == self.parent.list_points[0]:
                self.parent.list_points[1].line.set_animated(True)            
            elif self == self.parent.list_points[-1]:
                self.line.set_animated(True)            
            else:
                self.line.set_animated(True)            
                self.parent.list_points[point_number+1].line.set_animated(True)                


            canvas.draw()
            self.background = canvas.copy_from_bbox(self.point.axes.bbox)

            # now redraw just the rectangle
            axes.draw_artist(self.point)

            # and blit just the redrawn area
            canvas.blit(axes.bbox)


        def on_motion(self, event):

            if DraggablePoint.lock is not self:
                return
            if event.inaxes != self.point.axes: return
            self.point.center, xpress, ypress = self.press
            dx = event.xdata - xpress
            dy = event.ydata - ypress
            self.point.center = (self.point.center[0]+dx, self.point.center[1]+dy)

            canvas = self.point.figure.canvas
            axes = self.point.axes
            # restore the background region
            canvas.restore_region(self.background)

            # redraw just the current rectangle
            axes.draw_artist(self.point)

            point_number =  self.parent.list_points.index(self)
            self.x = self.point.center[0]
            self.y = self.point.center[1]


            # We check if the point is A or B        
            if self == self.parent.list_points[0]:
                # or we draw the other line of the point
                self.parent.list_points[1].line.set_animated(True)
                axes.draw_artist(self.parent.list_points[1].line)

            elif self == self.parent.list_points[-1]:
                # we draw the line of the point            
                axes.draw_artist(self.line)    

            else:
                # we draw the line of the point
                axes.draw_artist(self.line)
                #self.parent.list_points[point_number+1].line.set_animated(True)
                axes.draw_artist(self.parent.list_points[point_number+1].line)


            if self == self.parent.list_points[0]:
                # The first point is especial because it has no line
                line_x = [self.x, self.parent.list_points[1].x]
                line_y = [self.y, self.parent.list_points[1].y]      
                # this is were the line is updated
                self.parent.list_points[1].line.set_data(line_x, line_y)

            elif self == self.parent.list_points[-1]:
                line_x = [self.parent.list_points[-2].x, self.x]
                line_y = [self.parent.list_points[-2].y, self.y]
                self.line.set_data(line_x, line_y)        
            else:
                # The first point is especial because it has no line
                line_x = [self.x, self.parent.list_points[point_number+1].x]
                line_y = [self.y, self.parent.list_points[point_number+1].y]      
                # this is were the line is updated
                self.parent.list_points[point_number+1].line.set_data(line_x, line_y)

                line_x = [self.parent.list_points[point_number-1].x, self.x]
                line_y = [self.parent.list_points[point_number-1].y, self.y]
                self.line.set_data(line_x, line_y)        

            # blit just the redrawn area
            canvas.blit(axes.bbox)


        def on_release(self, event):

            'on release we reset the press data'
            if DraggablePoint.lock is not self:
                return

            self.press = None
            DraggablePoint.lock = None

            # turn off the rect animation property and reset the background
            self.point.set_animated(False)

            point_number =  self.parent.list_points.index(self)

            if self == self.parent.list_points[0]:
                self.parent.list_points[1].line.set_animated(False)            
            elif self == self.parent.list_points[-1]:
                self.line.set_animated(False)            
            else:
                self.line.set_animated(False)            
                self.parent.list_points[point_number+1].line.set_animated(False)       


            self.background = None

            # redraw the full figure
            self.point.figure.canvas.draw()

            self.x = self.point.center[0]
            self.y = self.point.center[1]
            print(self.x,self.y)
            Dragpoint_list.append(self.x)

        def disconnect(self):

            'disconnect all the stored connection ids'

            self.point.figure.canvas.mpl_disconnect(self.cidpress)
            self.point.figure.canvas.mpl_disconnect(self.cidrelease)
            self.point.figure.canvas.mpl_disconnect(self.cidmotion)
        

    class MyGraph(FigureCanvas):

        """A canvas that updates itself every second with a new plot."""

        def __init__(self, parent=None, width=5, height=4, dpi=100):

            self.fig = Figure(figsize=(width, height), dpi=dpi)
            self.axes = self.fig.add_subplot(111)

            self.axes.grid(True)

            super(MyGraph, self).__init__(self.fig)
            
            FigureCanvas.__init__(self, self.fig)
            self.setParent(parent)

            FigureCanvas.setSizePolicy(self,
                                        QtWidgets.QSizePolicy.Expanding,
                                        QtWidgets.QSizePolicy.Expanding)
            FigureCanvas.updateGeometry(self)

            # To store the 2 draggable points
            self.list_points = []

            self.show()
            self.plotDraggablePoints()
            self.plot()
            
            
        def plot(self):
            
            ax = self.figure.add_subplot(111)
            if (plt_type == 'semilog'):
                ax.semilogx(df['t'][1:], df['P_dash'][1:],linestyle='--', marker='o', color='b',label='Derivative Plot')
                ax.semilogx(df['t'][1:], df['delP'][1:],linestyle='--', marker='o', color='r',label="delP and (delP)', psia")
                ax.set_title("Semi-Log Plot")
            elif (plt_type == "log"):
                ax.loglog(df['t'][1:], df['P_dash'][1:],linestyle='--', marker='o', color='b',label='Derivative Plot')
                ax.loglog(df['t'][1:], df['delP'][1:],linestyle='--', marker='o', color='r',label="delP and (delP)', psia")
                ax.set_title("Log-Log Plot")

            ax.set_xlabel("Time, hrs")
            ax.set_ylabel("delP and P' (t*dp/dt), psia")
            ax.legend(loc='best')
            
            self.draw()


        def plotDraggablePoints(self, size=1):

            """Plot and define the 2 draggable points of the baseline"""

            # del(self.list_points[:])
            self.list_points.append(DraggablePoint(self, 10, 10, size))
            self.list_points.append(DraggablePoint(self, 50, 50, size))

            self.updateFigure()


        def clearFigure(self):

            """Clear the graph"""

            self.axes.clear()
            self.axes.grid(True)
            del(self.list_points[:])
            self.updateFigure()

            
        def updateFigure(self):

            """Update the graph. Necessary, to call after each plot"""

            self.draw()


    class MainWindow(QtWidgets.QMainWindow):

        def __init__(self, *args, **kwargs):
            super(MainWindow, self).__init__(*args, **kwargs)

            sc = MyGraph()#self, width=5, height=4, dpi=100)

            # Create toolbar, passing canvas as first parament, parent (self, the MainWindow) as second.
            toolbar = NavigationToolbar(sc, self)

            layout = QtWidgets.QVBoxLayout()
            layout.addWidget(toolbar)
            layout.addWidget(sc)

            # Create a placeholder widget to hold our toolbar and canvas.
            widget = QtWidgets.QWidget()
            widget.setLayout(layout)
            self.setCentralWidget(widget)

            self.show()            
            
            
    if __name__ == '__main__':

        app = QtWidgets.QApplication(sys.argv)
        ex = MainWindow()#MyGraph()
        sys.exit(app.exec_())
    return Dragpoint_list


# #### **Derivative & Conventional Method**


def df__FWBS(t1,t2,df):
    """Returns a dataframe for the data collected during the 
       Fully Wellbore Storage Period.
       List of inputs (in same order):
       - Starting time of FWBS period
       - Ending time of FWBS period
       - Dataframe of Welltest Data
    """
    
    import pandas as pd
    import numpy as np
    
    df_f = df[(df['t']>=t1) & (df['t']<=t2)]
    return df_f



def df__IARF(t1,t2,df):
    """Returns a dataframe for the data collected during the 
       Infinite Acting Radial Flow Period.
       List of inputs (in same order):
       - Starting time of IARF period
       - Ending time of IARF period
       - Dataframe of Welltest Data
    """  
    
    import pandas as pd
    import numpy as np
    
    df_i = df[(df['t']>=t1) & (df['t']<=t2)]
    return df_i



def FWBS(t1,t2,df,dict_data,method,t_FWBS=0):
    """Returns the Wellbore Storage Constant with a related plot depending upon 
       the method used for calculations (i.e., Derivative or Conventional).
       List of inputs (in same order):
       - Starting time of FWBS period
       - Ending time of FWBS period
       - Dataframe of Welltest Data
       - Dictionary of Reservoir fluid & rock and Well data
       - Method used (Derivative or Conventional)
       - Some time during FWBS (used only for derivative method)
    """
    
    import matplotlib.pyplot as plt
    import seaborn as sns
    import pandas as pd
    import numpy as np
    plt.style.use('fivethirtyeight')
    get_ipython().run_line_magic('matplotlib', 'inline')

    # To ignore warnings generated by the current version of seaborn 
    import warnings                  
    warnings.filterwarnings("ignore")

    # Getting the dataframe for fully wellbore storage period
    df_FWBS = df__FWBS(t1,t2,df)
    
    # Defining plot parameters
    plt.style.use('default')
    plt.figure(figsize=(10,5))
    
    # Different methods used for calculations
    if (method == 'Derivative'):
        print("Derivative Method:")
        plt.loglog(df['t'][1:], df['P_dash'][1:],linestyle='--', marker='o', color='b',label='Derivative Plot')
        plt.loglog(df['t'][1:], df['delP'][1:],linestyle='--', marker='o', color='r',label='Drawdown')
        plt.loglog(df_FWBS['t'], df_FWBS['P_dash'],linestyle='--', marker='o', color='orange',label='FWBS')
        plt.title('Log-Log Plot (FWBS)')

        plt.xlabel('Time, hrs')
        plt.ylabel("delP and P' (t*dp/dt), psia")

        plt.legend(loc='best')
        plt.grid()
        
        # For wellbore storage constant
        P_dash_FWBS = df['P_dash'][df['t']==t_FWBS].values
        Cs = (t_FWBS*dict_data['q']*dict_data['B'])/(P_dash_FWBS*24)
        print('Wellbore Storage Constant, Cs:',round(Cs[0],5),'bbl/psi')
    elif (method == 'Conventional'):
        print("Conventional Method:")
        plt.plot(df_FWBS['t'][0:], df_FWBS['Pwf'][0:],linestyle='--', marker='o', color='orange')
        plt.title('Pwf vs t (FWBS)')

        plt.xlabel('Time, hrs')
        plt.ylabel('Pwf, psia')
        plt.grid()
        
        # For wellbore storage constant
        coefficients_FWBS = np.polyfit(df_FWBS['t'],df_FWBS['Pwf'],1)
        slope_FWBS = abs(coefficients_FWBS[0])
        Cs = (dict_data['q']*dict_data['B'])/(slope_FWBS*24)
        print('Wellbore Storage Constant, Cs:',round(Cs,5),'bbl/psi')



def IARF(t1,t2,df,dict_data,method,ts=0):
    """Returns the Reservoir Permeability and Near Wellbore Skin with a related plot 
       depending upon the method used for calculations (i.e., Derivative or Conventional).
       List of inputs (in same order):
       - Starting time of IARF period
       - Ending time of IARF period
       - Dataframe of Welltest Data
       - Dictionary of Reservoir fluid & rock and Well data
       - Method used (Derivative or Conventional)
       - Some time during IARF (used only for derivative method)
    """
    
    import matplotlib.pyplot as plt
    import seaborn as sns
    import pandas as pd
    import numpy as np
    plt.style.use('fivethirtyeight')
    get_ipython().run_line_magic('matplotlib', 'inline')

    # To ignore warnings generated by the current version of seaborn 
    import warnings                  
    warnings.filterwarnings("ignore")
    
    # Getting the dataframe for fully wellbore storage period
    df_IARF = df__IARF(t1,t2,df)
    
    # Defining plot parameters
    plt.style.use('default')
    plt.figure(figsize=(10,5))

    # Different methods used for calculations
    if(method == 'Derivative'):
        print("Derivative Method:")
        plt.loglog(df['t'][1:], df['P_dash'][1:],linestyle='--', marker='o', color='b',label='Derivative Plot')
        plt.loglog(df['t'][1:], df['delP'][1:],linestyle='--', marker='o', color='r',label='Drawdown')
        plt.loglog(df_IARF['t'], df_IARF['P_dash'],linestyle='--', marker='o', color='orange',label='IARF')
        plt.title('Log-Log Plot (IARF)')

        plt.xlabel('Time, hrs')
        plt.ylabel("delP and P' (t*dp/dt), psia")

        plt.legend(loc='best')
        plt.grid()

        # For Reservoir Permeability
        P_dash_stab = np.mean(df_IARF['P_dash'])
        K = (70.6*dict_data['q']*dict_data['B']*dict_data['mu'])/(P_dash_stab*dict_data['h'])
        print('Reservoir Premability, K:',round(K,3),'mD')

        # For Near Wellbore Skin
        delPs = df_IARF['delP'][df_IARF['t']==ts].values
        Ps_dash = df_IARF['P_dash'][df_IARF['t']==ts].values
        S = 1.15*((delPs/(2.303*Ps_dash))-np.log10(ts)
                  -np.log10(K/(dict_data['phi']*dict_data['mu']*dict_data['ct']*(dict_data['rw']**2)))+3.23)
        print('Near Wellbore Skin, S:',round(S[0],3))
    elif (method == 'Conventional'):
        print("Conventional Method:")
        plt.semilogx(df['t'][0:], df['Pwf'][0:],linestyle='--', marker='o', color='b',label='Drawdown')
        plt.semilogx(df_IARF['t'], df_IARF['Pwf'],linestyle='--', marker='o', color='orange',label='IARF')
        plt.title('Semi-Log Plot (IARF)')

        plt.xlabel('Time, hrs')
        plt.ylabel("Pwf, psia")

        plt.legend(loc='best')
        plt.grid()
        
        # For Reservoir Permeability and Near Wellbore Skin
        df_IARF['logt'] = np.log10(df_IARF['t'])
        coefficients_IARF = np.polyfit(df_IARF['logt'],df_IARF['Pwf'],1)
        slope_IARF = abs(coefficients_IARF[0])
        
        Pwf_1hr = coefficients_IARF[1]
        
        K = (162.6*dict_data['q']*dict_data['mu']*dict_data['B'])/(slope_IARF*dict_data['h'])
        print('Reservoir Premability, K:',round(K,3),'mD')
        
        S = 1.15*(((dict_data['Pi']-Pwf_1hr)/(slope_IARF))-np.log10(1)
                    -np.log10(K/(dict_data['phi']*dict_data['mu']*dict_data['ct']*(dict_data['rw']**2)))+3.23)
        print('Near Wellbore Skin, S:',round(S,3))

